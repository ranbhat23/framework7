<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PM2 Event Stream Dashboard</title>
    <style>
        table {
            border-collapse: collapse;
            width: 70%; /* Made table wider */
            margin-top: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .online { color: green; font-weight: bold; }
        .stopped { color: red; font-weight: bold; }
        .errored { color: orange; font-weight: bold; } /* Added specific errored style */
        .previous-status { color: gray; font-size: 0.8em; margin-left: 10px; }
    </style>
</head>
<body>
    <h1>PM2 Process Status</h1>
    <p>Displays current status and previous status if changed recently.</p>
    
    <table id="process-table">
        <thead>
            <tr>
                <th>Process Name</th>
                <th>Current Status</th>
                <th>ID</th>
                <th>Memory (MB)</th>
                <th>Uptime</th>
            </tr>
        </thead>
        <tbody id="process-table-body">
            <!-- Process rows will be inserted here by JavaScript -->
        </tbody>
    </table>

    <p>Last event received shown below:</p>
    <pre id="status-output">Waiting for PM2 events...</pre>

    <script src="http://localhost:3001/socket.io/socket.io.js"></script>
    <script>
        const socket = io('http://localhost:3001');
        const statusOutput = document.getElementById('status-output');
        const tableBody = document.getElementById('process-table-body');
        
        // --- Store history of process statuses here ---
        const processHistory = {}; 

        socket.on('connect', () => {
            console.log('Connected to server');
        });

        function formatMemory(bytes) {
            return (bytes / (1024 * 1024)).toFixed(2);
        }

        function formatUptime(uptimeMs) {
            if (!uptimeMs) return 'N/A';
            const seconds = Math.floor(uptimeMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days}d ${hours % 24}h`;
            if (hours > 0) return `${hours % 24}h ${minutes % 60}m`;
            if (minutes > 0) return `${minutes % 60}m ${seconds % 60}s`;
            return `${seconds}s`;
        }
        
        function updateProcessRow(processData) {
            const pm2_env = processData.pm2_env;
            const processName = processData.name;
            const processId = processData.pm_id;
            const currentStatus = pm2_env.status;
            const memory = formatMemory(processData.monit.memory);
            const uptime = formatUptime(pm2_env.pm_uptime ? Date.now() - pm2_env.pm_uptime : null);

            let row = document.getElementById(`process-row-${processId}`);
            let previousStatus = processHistory[processId] || 'N/A';
            
            // If the status has changed from the last time we saw it, update the history
            if (currentStatus !== previousStatus && previousStatus !== 'N/A') {
                // Keep the previous status visible for a short time or until overwritten
            }
            
            // Always update history to the current status after processing
            processHistory[processId] = currentStatus;

            if (!row) {
                row = document.createElement('tr');
                row.id = `process-row-${processId}`;
                tableBody.appendChild(row);
            } else {
                row.innerHTML = ''; // Clear for update
            }

            // Create and append cells
            const cellName = document.createElement('td');
            cellName.textContent = processName;
            row.appendChild(cellName);

            const cellStatus = document.createElement('td');
            cellStatus.innerHTML = `<span class="${currentStatus}">${currentStatus}</span>`;
            
            // Add previous status indicator if it was something different
            if (previousStatus !== 'N/A' && previousStatus !== currentStatus) {
                 cellStatus.innerHTML += `<span class="previous-status">(was ${previousStatus})</span>`;
            }

            row.appendChild(cellStatus);

            const cellId = document.createElement('td');
            cellId.textContent = processId;
            row.appendChild(cellId);

            const cellMemory = document.createElement('td');
            cellMemory.textContent = memory + ' MB';
            row.appendChild(cellMemory);

            const cellUptime = document.createElement('td');
            cellUptime.textContent = uptime;
            row.appendChild(cellUptime);
        }

        // Listen for initial list snapshot
        socket.on('pm2status-list', (statusData) => {
            console.log('Received initial status list:', statusData);
            tableBody.innerHTML = ''; 
            if (Array.isArray(statusData)) {
                statusData.forEach(p => {
                    // Initialize history with the starting status
                    processHistory[p.pm_id] = p.pm2_env.status; 
                    updateProcessRow(p);
                });
            }
        });
        
        // Listen for specific event updates
        socket.on('pm2-event-update', (eventPayload) => {
            statusOutput.textContent = `Event Type: ${eventPayload.event}\n\n` + 
                                        JSON.stringify(eventPayload.data, null, 2);
            if (eventPayload.data) {
                updateProcessRow(eventPayload.data);
            }
        });
    </script>
</body>
</html>
